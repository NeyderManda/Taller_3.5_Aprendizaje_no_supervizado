<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Laboratorio de Clustering Pro</title>
    
    <!-- 1. Cargamos React y ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- 2. Cargamos Babel para traducir el código JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- 3. Cargamos Tailwind CSS para los estilos -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- 4. Estilos extra para animaciones -->
    <style>
        body { background-color: #f8fafc; }
        .fade-in { animation: fadeIn 0.5s ease-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
    </style>
</head>
<body>
    <div id="root"></div>

    <!-- 5. Tu Código de la Aplicación -->
    <script type="text/babel">
        const { useState, useEffect, useMemo, useRef } = React;

        // --- ICONOS (Reemplazo manual de Lucide para HTML standalone) ---
        const Icon = ({ children, size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                {children}
            </svg>
        );

        const Cpu = (p) => <Icon {...p}><rect x="4" y="4" width="16" height="16" rx="2"/><rect x="9" y="9" width="6" height="6"/><path d="M9 1V4"/><path d="M15 1V4"/><path d="M9 20V23"/><path d="M15 20V23"/><path d="M20 9H23"/><path d="M20 14H23"/><path d="M1 9H4"/><path d="M1 14H4"/></Icon>;
        const Layers = (p) => <Icon {...p}><path d="m12.83 2.18a2 2 0 0 0-1.66 0L2.6 6.08a1 1 0 0 0 0 1.83l8.58 3.91a2 2 0 0 0 1.66 0l8.58-3.9a1 1 0 0 0 0-1.83Z"/><path d="m22 17.65-9.17 4.16a2 2 0 0 1-1.66 0L2 17.65"/><path d="m22 12.65-9.17 4.16a2 2 0 0 1-1.66 0L2 12.65"/></Icon>;
        const Zap = (p) => <Icon {...p}><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></Icon>;
        const Settings = (p) => <Icon {...p}><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.47a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></Icon>;
        const Eye = (p) => <Icon {...p}><path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"/><circle cx="12" cy="12" r="3"/></Icon>;
        const Info = (p) => <Icon {...p}><circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/></Icon>;
        const Sparkles = (p) => <Icon {...p}><path d="m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275 1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L21 12l-5.813-1.912a2 2 0 0 1-1.275-1.275L12 3Z"/></Icon>;
        const Disc = (p) => <Icon {...p}><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="3"/></Icon>;
        const Activity = (p) => <Icon {...p}><path d="M22 12h-4l-3 9L9 3l-3 9H2"/></Icon>;
        const BarChart3 = (p) => <Icon {...p}><path d="M3 3v18h18"/><path d="M18 17V9"/><path d="M13 17V5"/><path d="M8 17v-3"/></Icon>;
        const MousePointer2 = (p) => <Icon {...p}><path d="m12 12 8.485 8.485"/><path d="m12 12 5.657-5.657L12 2.11 7.757 16.243 12 12Z"/></Icon>;

        // --- COLORES ---
        const COLORS = ['#ef4444', '#8b5cf6', '#10b981', '#f59e0b', '#06b6d4', '#ec4899', '#6366f1', '#84cc16'];
        const COLOR_NOISE = '#cbd5e1';

        // --- LÓGICA DE DATOS ---
        const generateMarketingData = (n) => {
            const points = [];
            const centers = [{ x: 0.3, y: 0.3 }, { x: 0.75, y: 0.75 }, { x: 0.25, y: 0.75 }, { x: 0.8, y: 0.25 }];
            for (let i = 0; i < n; i++) {
                const center = centers[Math.floor(Math.random() * centers.length)];
                points.push({
                    id: i,
                    x: Math.max(0, Math.min(1, center.x + (Math.random() - 0.5) * 0.18)),
                    y: Math.max(0, Math.min(1, center.y + (Math.random() - 0.5) * 0.18)),
                    label: -1
                });
            }
            return points;
        };

        const generateSensorData = (n) => {
            const points = [];
            for (let i = 0; i < n * 0.9; i++) {
                const isUpper = i < (n * 0.9) / 2;
                const angle = Math.PI * (i / ((n * 0.9) / 2));
                if (isUpper) {
                    points.push({ id: i, x: 0.3 + 0.3 * Math.cos(angle) + (Math.random()-0.5)*0.05, y: 0.3 + 0.3 * Math.sin(angle) + (Math.random()-0.5)*0.05, label: -1 }); 
                } else {
                    const angle2 = Math.PI + Math.PI * ((i - (n*0.9)/2)/((n*0.9)/2));
                    points.push({ id: i, x: 0.6 + 0.3 * Math.cos(angle2) + (Math.random()-0.5)*0.05, y: 0.6 + 0.3 * Math.sin(angle2) + (Math.random()-0.5)*0.05, label: -1 });
                }
            }
            for (let i = 0; i < n * 0.1; i++) { points.push({ id: n + i, x: Math.random(), y: Math.random(), label: -1 }); }
            return points;
        };

        const generateGeoData = (n) => {
            const points = [];
            const noiseCount = Math.floor(n * 0.15);
            const structureCount = n - noiseCount;
            for (let i = 0; i < structureCount; i++) {
                const angle = Math.random() * 2 * Math.PI;
                const rBase = Math.random();
                let r = 0;
                if (rBase < 0.25) r = 0.0 + Math.random() * 0.12;
                else if (rBase < 0.6) r = 0.25 + (Math.random() - 0.5) * 0.05;
                else r = 0.42 + (Math.random() - 0.5) * 0.05;
                points.push({ id: i, x: 0.5 + r * Math.cos(angle), y: 0.5 + r * Math.sin(angle), label: -1 });
            }
            for (let i = 0; i < noiseCount; i++) { points.push({ id: structureCount + i, x: Math.random(), y: Math.random(), label: -1 }); }
            return points;
        };

        // --- ALGORITMOS SIMPLIFICADOS (JS) ---
        const dist = (p1, p2) => Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);

        const runKMeans = (points, k) => {
            let centroids = points.slice(0, k).map(p => ({ x: p.x, y: p.y }));
            const newPoints = points.map(p => ({...p}));
            for (let iter = 0; iter < 10; iter++) {
                newPoints.forEach(p => {
                    let minDist = Infinity;
                    centroids.forEach((c, idx) => {
                        const d = dist(p, c);
                        if (d < minDist) { minDist = d; p.label = idx; }
                    });
                });
                centroids = centroids.map((c, idx) => {
                    const clusterPoints = newPoints.filter(p => p.label === idx);
                    if (clusterPoints.length === 0) return c;
                    return { 
                        x: clusterPoints.reduce((s, p) => s + p.x, 0) / clusterPoints.length, 
                        y: clusterPoints.reduce((s, p) => s + p.y, 0) / clusterPoints.length 
                    };
                });
            }
            return { points: newPoints, centroids };
        };

        const runDBSCAN = (points, eps, minPts) => {
            const newPoints = points.map(p => ({ ...p, label: -2 }));
            let clusterIdx = 0;
            for (let i = 0; i < newPoints.length; i++) {
                if (newPoints[i].label !== -2) continue;
                const neighbors = newPoints.map((p, idx) => ({ idx, d: dist(p, newPoints[i]) })).filter(n => n.d <= eps).map(n => n.idx);
                if (neighbors.length < minPts) { 
                    newPoints[i].label = -1;
                } else {
                    newPoints[i].label = clusterIdx;
                    let seedSet = [...neighbors];
                    let seedIndex = 0;
                    while(seedIndex < seedSet.length) {
                        const currIdx = seedSet[seedIndex++];
                        if (newPoints[currIdx].label === -1) newPoints[currIdx].label = clusterIdx;
                        if (newPoints[currIdx].label !== -2) continue;
                        newPoints[currIdx].label = clusterIdx;
                        const currNeighbors = newPoints.map((p, idx) => ({ idx, d: dist(p, newPoints[currIdx]) })).filter(n => n.d <= eps).map(n => n.idx);
                        if (currNeighbors.length >= minPts) seedSet.push(...currNeighbors);
                    }
                    clusterIdx++;
                }
            }
            return { points: newPoints, centroids: [] };
        };

        const runHierarchical = (points, k) => {
            const limit = 400; // Límite para rendimiento en browser
            const subset = points.slice(0, limit).map((p, i) => ({...p, originalIndex: i, label: i}));
            const distances = [];
            for(let i=0; i<subset.length; i++) {
                for(let j=i+1; j<subset.length; j++) {
                    distances.push({i, j, d: dist(subset[i], subset[j])});
                }
            }
            distances.sort((a, b) => a.d - b.d);
            const parent = Array.from({length: subset.length}, (_, i) => i);
            const find = (i) => parent[i] === i ? i : (parent[i] = find(parent[i]));
            const union = (i, j) => { const rI = find(i), rJ = find(j); if (rI !== rJ) parent[rI] = rJ; };
            
            let numClusters = subset.length;
            let edgeIdx = 0;
            while (numClusters > k && edgeIdx < distances.length) {
                const {i, j} = distances[edgeIdx++];
                if (find(i) !== find(j)) { union(i, j); numClusters--; }
            }
            
            const labelMap = new Map();
            let nextLabel = 0;
            return {
                points: points.map((p, i) => {
                    if (i >= limit) return { ...p, label: -1 };
                    const root = find(i);
                    if (!labelMap.has(root)) labelMap.set(root, nextLabel++);
                    return { ...p, label: labelMap.get(root) };
                }),
                centroids: []
            };
        };

        const getInterpretation = (algo, type) => {
            const key = `${type}-${algo}`;
            if (key.includes('marketing-kmeans')) return "✅ IDEAL: Grupos compactos y redondos. K-Means es perfecto.";
            if (key.includes('marketing-dbscan')) return "⚠️ CUIDADO: Puede unir grupos si están cerca. Ajusta Epsilon.";
            if (key.includes('marketing-hierarchical')) return "✅ BUENO: Detecta bien, pero es más lento.";
            
            if (key.includes('sensor-kmeans')) return "❌ ERROR: Corta las lunas con líneas rectas.";
            if (key.includes('sensor-dbscan')) return "✅ EXCELENTE: Sigue la forma de medialuna.";
            if (key.includes('sensor-hierarchical')) return "⚠️ REGULAR: Depende del método de enlace.";
            
            if (key.includes('geo-kmeans')) return "❌ ERROR: Divide los anillos como pastel.";
            if (key.includes('geo-dbscan')) return "✅ EL MEJOR: Detecta anillos anidados.";
            if (key.includes('geo-hierarchical')) return "✅ INTERESANTE: Puede cerrar los anillos.";
            
            return "Selecciona una combinación.";
        };

        // --- APP COMPONENT ---
        function ClusteringApp() {
            const [points, setPoints] = useState([]);
            const [algorithm, setAlgorithm] = useState('kmeans');
            const [k, setK] = useState(3);
            const [eps, setEps] = useState(0.06);
            const [minPts, setMinPts] = useState(4);
            const [dataType, setDataType] = useState('geo');
            const [showConnections, setShowConnections] = useState(true);
            const [mousePos, setMousePos] = useState({ x: 0.5, y: 0.5 });

            useEffect(() => { setPoints(generateGeoData(600)); }, []);

            const handleGenerateData = (type) => {
                setDataType(type);
                if (type === 'marketing') setPoints(generateMarketingData(500));
                else if (type === 'sensor') setPoints(generateSensorData(500));
                else setPoints(generateGeoData(600));
            };

            const { displayPoints, centroids } = useMemo(() => {
                if (points.length === 0) return { displayPoints: [], centroids: [] };
                let res;
                if (algorithm === 'kmeans') res = runKMeans(points, k);
                else if (algorithm === 'dbscan') res = runDBSCAN(points, eps, minPts);
                else res = runHierarchical(points, k);
                return { displayPoints: res.points, centroids: res.centroids };
            }, [points, algorithm, k, eps, minPts]);

            const clustersCount = new Set(displayPoints.map(p => p.label).filter(l => l !== -1)).size;
            const noiseCount = displayPoints.filter(p => p.label === -1).length;

            const handleMouseMove = (e) => {
                const rect = e.currentTarget.getBoundingClientRect();
                setMousePos({
                    x: (e.clientX - rect.left) / rect.width,
                    y: 1 - (e.clientY - rect.top) / rect.height
                });
            };

            return (
                <div className="flex flex-col lg:flex-row h-screen font-sans overflow-hidden bg-slate-50 text-slate-800">
                    
                    {/* SIDEBAR */}
                    <div className="w-full lg:w-[350px] bg-white border-r border-slate-200 flex flex-col z-20 shadow-xl overflow-y-auto shrink-0 h-auto max-h-[40vh] lg:max-h-full lg:h-full">
                        <div className="p-6 bg-indigo-600 text-white shadow-md sticky top-0 z-30">
                            <div className="flex items-center gap-3">
                                <div className="bg-white/20 p-2 rounded-xl"><Cpu size={24}/></div>
                                <div><h1 className="text-xl font-bold">Clustering Pro</h1><p className="text-xs opacity-80 uppercase">Simulador Portable</p></div>
                            </div>
                        </div>

                        <div className="p-6 space-y-6">
                            <section>
                                <div className="flex items-center gap-2 mb-3 text-xs font-bold text-slate-400 uppercase tracking-widest"><Layers size={14}/> 1. Datos</div>
                                <div className="grid gap-2">
                                    {[
                                        {id:'geo', icon: Disc, t:'Anillos', d:'No convexo'},
                                        {id:'sensor', icon: Activity, t:'Lunas', d:'Anomalías'},
                                        {id:'marketing', icon: BarChart3, t:'Blobs', d:'Estándar'}
                                    ].map(item => (
                                        <button key={item.id} onClick={() => handleGenerateData(item.id)} className={`flex items-center gap-3 p-3 rounded-xl border text-left transition-all ${dataType === item.id ? 'border-indigo-500 bg-indigo-50' : 'bg-white hover:bg-slate-50'}`}>
                                            <div className={`p-2 rounded-lg ${dataType===item.id?'bg-indigo-600 text-white':'bg-slate-100 text-slate-400'}`}><item.icon size={16}/></div>
                                            <div><div className="text-sm font-bold">{item.t}</div><div className="text-[10px] text-slate-500">{item.d}</div></div>
                                        </button>
                                    ))}
                                </div>
                            </section>

                            <section>
                                <div className="flex items-center gap-2 mb-3 text-xs font-bold text-slate-400 uppercase tracking-widest"><Zap size={14}/> 2. Algoritmo</div>
                                <div className="flex flex-col gap-2">
                                    {[{id:'kmeans',n:'K-Means'},{id:'dbscan',n:'DBSCAN'},{id:'hierarchical',n:'Jerárquico'}].map(algo => (
                                        <button key={algo.id} onClick={()=>setAlgorithm(algo.id)} className={`flex justify-between px-4 py-3 rounded-xl border transition-all ${algorithm===algo.id?'bg-slate-800 text-white':'bg-white hover:bg-slate-50'}`}>
                                            <span className="font-bold text-sm">{algo.n}</span>
                                        </button>
                                    ))}
                                </div>
                            </section>

                            <section className="bg-slate-50 p-4 rounded-xl border border-slate-200">
                                <div className="flex justify-between items-center mb-4 text-xs font-bold text-slate-500 uppercase"><div className="flex gap-2"><Settings size={14}/> Ajustes</div> {algorithm==='kmeans'&& <button onClick={()=>setShowConnections(!showConnections)} className="flex items-center gap-1 text-indigo-600 bg-white px-2 py-1 rounded border"><Eye size={12}/> {showConnections?'Lineas ON':'Lineas OFF'}</button>}</div>
                                {algorithm !== 'dbscan' ? (
                                    <div><div className="flex justify-between text-xs mb-2 font-bold"><span>K Clusters</span><span className="text-indigo-600">{k}</span></div><input type="range" min="2" max="10" value={k} onChange={e=>setK(parseInt(e.target.value))} className="w-full h-2 bg-slate-200 rounded-lg accent-indigo-600"/></div>
                                ) : (
                                    <div className="space-y-4">
                                        <div><div className="flex justify-between text-xs mb-2 font-bold"><span className="flex items-center gap-1">Radio <span className="bg-orange-100 text-orange-600 px-1 rounded border border-orange-200 text-[9px]"><MousePointer2 size={8} className="inline"/> Mouse</span></span><span className="text-indigo-600">{eps.toFixed(2)}</span></div><input type="range" min="0.02" max="0.15" step="0.005" value={eps} onChange={e=>setEps(parseFloat(e.target.value))} className="w-full h-2 bg-slate-200 rounded-lg accent-orange-500"/></div>
                                        <div><div className="flex justify-between text-xs mb-2 font-bold"><span>Min Pts</span><span className="text-indigo-600">{minPts}</span></div><input type="range" min="2" max="10" value={minPts} onChange={e=>setMinPts(parseInt(e.target.value))} className="w-full h-2 bg-slate-200 rounded-lg accent-indigo-600"/></div>
                                    </div>
                                )}
                            </section>
                        </div>
                    </div>

                    {/* MAIN AREA */}
                    <div className="flex-1 relative bg-slate-100 flex flex-col p-2 lg:p-6 overflow-hidden h-full">
                        <div className="flex-1 flex items-center justify-center relative w-full min-h-0">
                            <div className="relative w-full max-w-[500px] xl:max-w-[650px] aspect-square bg-white rounded-[2rem] shadow-2xl border border-slate-200 overflow-hidden">
                                <svg className="w-full h-full cursor-crosshair" viewBox="0 0 1 1" preserveAspectRatio="none" onMouseMove={handleMouseMove}>
                                    {/* Lineas K-Means */}
                                    {algorithm === 'kmeans' && showConnections && displayPoints.map(p => {
                                        if(p.label===-1 || !centroids[p.label]) return null;
                                        const c = centroids[p.label];
                                        return <line key={`l-${p.id}`} x1={p.x} y1={1-p.y} x2={c.x} y2={1-c.y} stroke={COLORS[p.label%COLORS.length]} strokeWidth="0.001" opacity="0.2"/>
                                    })}
                                    {/* Tool DBSCAN */}
                                    {algorithm === 'dbscan' && <circle cx={mousePos.x} cy={1-mousePos.y} r={eps} fill="rgba(249, 115, 22, 0.1)" stroke="rgba(249, 115, 22, 0.5)" strokeWidth="0.002" strokeDasharray="0.01 0.01"/>}
                                    {/* Puntos */}
                                    {displayPoints.map(p => (
                                        <circle key={p.id} cx={p.x} cy={1-p.y} r={p.label===-1?0.006:0.009} fill={p.label===-1?COLOR_NOISE:COLORS[p.label%COLORS.length]} opacity={p.label===-1?0.4:0.8} className="transition-all duration-300"/>
                                    ))}
                                    {/* Centroides */}
                                    {algorithm === 'kmeans' && centroids.map((c,i) => (
                                        <g key={`c-${i}`}><circle cx={c.x} cy={1-c.y} r="0.015" fill="white" stroke={COLORS[i%COLORS.length]} strokeWidth="0.005"/><circle cx={c.x} cy={1-c.y} r="0.04" fill={COLORS[i%COLORS.length]} opacity="0.2" className="animate-pulse"/></g>
                                    ))}
                                </svg>
                                {/* HUD */}
                                <div className="absolute top-4 right-4 bg-white/90 backdrop-blur px-3 py-1.5 rounded-lg shadow border flex gap-3 text-xs">
                                    <div className="text-right"><strong>{clustersCount}</strong> <span className="text-[9px] text-slate-400 uppercase">Clusters</span></div>
                                    <div className="w-px bg-slate-200"></div>
                                    <div className="text-right"><strong>{noiseCount}</strong> <span className="text-[9px] text-slate-400 uppercase">Ruido</span></div>
                                </div>
                            </div>
                        </div>
                        {/* Explicación */}
                        <div className="mt-4 flex justify-center shrink-0 z-20">
                            <div className="bg-white border border-slate-200 rounded-2xl p-4 shadow-lg max-w-2xl w-full flex gap-4">
                                <div className="bg-indigo-50 p-3 rounded-xl text-indigo-600 hidden sm:block"><Info size={24}/></div>
                                <div><h3 className="text-xs font-bold text-indigo-500 uppercase tracking-widest mb-1">Análisis</h3><p className="text-sm text-slate-700">{getInterpretation(algorithm, dataType)}</p></div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<ClusteringApp />);
    </script>
</body>
</html>
